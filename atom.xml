<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[My Octopress Blog]]></title>
  <link href="http://TakashiNakagawa.github.io/atom.xml" rel="self"/>
  <link href="http://TakashiNakagawa.github.io/"/>
  <updated>2013-05-25T09:00:12+09:00</updated>
  <id>http://TakashiNakagawa.github.io/</id>
  <author>
    <name><![CDATA[Your Name]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[sicp]]></title>
    <link href="http://TakashiNakagawa.github.io/blog/2013/05/25/sicp/"/>
    <updated>2013-05-25T08:59:00+09:00</updated>
    <id>http://TakashiNakagawa.github.io/blog/2013/05/25/sicp</id>
    <content type="html"><![CDATA[<h2>素数性のテスト</h2>

<pre><code>(define (square n)
  (* n n))

(define (smallest-divisor n)
  (find-divisor n 2))

(define (find-divisor n test-divisor)
(cond ((&gt; (square test-divisor) n) n)
  ((divides? test-divisor n) test-divisor)
  (else (find-divisor n (+ test-divisor 1)))))

(define (divides? a b)
  (= (remainder b a) 0))

(define (prime? n)
  (= n (smallest-divisor n)))

; 実行確認
(print (prime? 4))
</code></pre>

<h2>問1.21</h2>

<blockquote><p>smalleset-divisor手続きを使い、次の数の最小除数を見つけよ:199, 1999, 19999</p></blockquote>

<h5>解答</h5>

<pre><code>(print (smallest-divisor 199)) ;199
(print (smallest-divisor 1999)) ;1999
(print (smallest-divisor 19999)) ;7
</code></pre>

<h2>問1.22     </h2>

<blockquote><p>殆どのLispの実装には基本手続きruntimeがあり、システムが走った時間を示す整数を返す。
次のtimed-prime-test手続きは整数nで呼び出されると、nを印字し、nが素数かどうかを調べ、nが素数なら手続きは３つの星印とテストに要した時間を印字する</p></blockquote>

<pre><code>(define (timed-prime-test n)
        (newline)
        (display n)
        (start-prime-test n (runtime)))

(define (start-prime-test n start-time)
        (if (prime? n)
                (report-prime (- (runtime) start-time))))

(define (report-prime elapsed-time)
        (display "***")
        (display elapsed-time)) 
</code></pre>

<blockquote><p>この手続を使い、指定範囲の連続する奇整数について素数性を調べる手続き search-for-primesを書け。<br/>
その手続で、それぞれ1000,10000,100000,10000000より大きい、小さい方から3つの素数を見つけよ。<br/>
素数をテストする時間に注意せよ。テストのアルゴリズムはΘ(√n)の増加の程度だから、10000前後の素数のテストは1000前後の素数のテストの√10倍かかると考えよ。<br/>
時間のデータはこれを支持するか。100000, 10000000のデータは√n予想の通りだろうか。<br/>
結果はプログラムが計算に必要なステップ数に比例した時間で走るという考えに合っているか。</p></blockquote>

<h5>解答</h5>

<p>runtimeがつかえない! って事で調べてみた結果、
<a href="http://d.hatena.ne.jp/awacio/20100221/1266759383">ここのブログ</a>を参考に</p>

<pre><code>(use srfi-19)
current-inexact-milliseconds
time-difference
</code></pre>

<p>を使用してみました。感謝です。
実現すべき事は、入力値からスタートし、奇数毎に素数判定を行い、3連続で素数判定が出てくるまでの時間でいいはず。</p>

<p>解いている途中えデバッグ出力をしたい場面が何度かあった。<br/>
下記のような関数を用意すると便利</p>

<pre><code>(define (log  msg)
  (display msg (current-error-port))
  (newline))
</code></pre>

<p>解いた結果</p>

<pre><code>(define (search-for-primes stt end count start-time)
  (cond
    ((&gt; stt end)
     (exit))
    ((= count 3)
     (newline)
     (exit))
    ((even? stt)
      (search-for-primes (+ stt 1) end count start-time))
    (else (cond
            ((prime? stt)
              (newline)
              (display stt)
              (start-prime-test stt start-time)
              (search-for-primes (+ stt 2) end (+ count 1) start-time))
            (else (search-for-primes (+ stt 2) end count start-time))))))
</code></pre>

<blockquote><p>実行結果</p></blockquote>

<p>(print (search-for-primes 10000 20000 0 (current-time)))</p>

<pre><code>10007***#&lt;time-duration 0.000113000&gt;  
10009***#&lt;time-duration 0.000203000&gt;  
10037***#&lt;time-duration 0.000395000&gt;  
</code></pre>

<p>(print (search-for-primes 100000 200000 0 (current-time)))</p>

<pre><code>100003***#&lt;time-duration 0.000210000&gt;
100019***#&lt;time-duration 0.000475000&gt;
100043***#&lt;time-duration 0.000769000&gt;
</code></pre>

<p>(print (search-for-primes 1000000 2000000 0 (current-time)))</p>

<pre><code>1000003***#&lt;time-duration 0.000673000&gt;
1000033***#&lt;time-duration 0.001394000&gt;
1000037***#&lt;time-duration 0.002023000&gt;
</code></pre>

<p>桁数:10000→100000(x10)で実行時間:0.0004→0.0008(x2)<br/>
桁数:100000→100000(x10)で実行時間:0.0008→0.002(x2.5)<br/>
√10 = 3.16&hellip;<br/>
大体合っているといえるのかな</p>

<h2>問1.23</h2>

<blockquote><p>本節の始めのsmalleset-divisorは多くの不要な計算をする：数が２で割切れるか調べた後は、より大きい偶数で割けれるか調べるのは無意味である。test-divisorが使う値は、2,3,4,5,…であるべきだ。<br/>
この変更を実装するため、入力が２なら３を返し、そうでなければ入力に２足したものを返す手続きnextを定義せよ。
smallest-divisorを(+ test-divisor 1)ではなく、(next test-divisor)を使うように修正せよ。
このように修正したsmallest-divisorにしたtimed-prime-testで、問題1.22で見つけた12個の素数をテストせよ。
この修正はテストのステップを半分にしたので、２倍速く走る事が期待される。この期待は確かめられるか。そうでなければ、得られた２つのアルゴリズムの速度の比はどうであったか。それが２と違う事情を説明せよ。</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Octopressのテーマ設定]]></title>
    <link href="http://TakashiNakagawa.github.io/blog/2013/05/25/theme/"/>
    <updated>2013-05-25T08:49:00+09:00</updated>
    <id>http://TakashiNakagawa.github.io/blog/2013/05/25/theme</id>
    <content type="html"><![CDATA[<h1>Octopressのテーマの変更方法</h1>

<p><a href="http://www.evolument.com/blog/2013/03/02/top-10-plus-octopress-themes/">こちらのリンク先</a>から選んで変更するだけ</p>

<p>今適用しているテーマに変更する場合は、</p>

<pre><code>cd octopress
git clone git://github.com/sevenadrian/foxslide.git .themes/foxslide
rake install['foxslide']
rake generate
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Mastering OpenCV 8章]]></title>
    <link href="http://TakashiNakagawa.github.io/blog/2013/05/17/opencv8/"/>
    <updated>2013-05-17T17:25:00+09:00</updated>
    <id>http://TakashiNakagawa.github.io/blog/2013/05/17/opencv8</id>
    <content type="html"><![CDATA[<h2><em>Chapter 8: Face Recognition using Eigenfaces or Fisherfaces</em></h2>

<h3>概要</h3>

<p>Mastering Opencv with Practical Computer Vision Projectsの8章を読んでみた。</p>

<p>アプリを実行して動作の確認をする事が出来たので、改めて内容をまとめて直してみる。</p>

<p>本章の内容は以下の４つのステップに分かれている。
各ステップは丁寧に書かれており、最終的なアプリはEigenfaces or Fisherfacesを<br/>
ソースコード上で切り分けて実行する事が出来るようになっている。</p>

<ul>
<li>Step 1: Face detection</li>
<li>Step 2: Face preprocessing</li>
<li>Step 3: Collecting faces and learning from them</li>
<li>Step 4: Face recognition</li>
</ul>


<h2>Step1: Face detection  </h2>

<ul>
<li>Haar-based face detector</li>
<li>LBP-based face detector</li>
</ul>


<h5>Implementing face detection using OpenCV</h5>

<h5>Loading a Haar or LBP detector for object or face detection</h5>

<pre><code>CascadeClassifier faceDetector:
try{
  faceDetector.load(fileCascadeFilenname);
} catch (cv::Exception e){}
if (faceDetector.empty()){
  cerr &lt;&lt; "Error &lt;&lt; endl;
  exit(1);
}
</code></pre>

<h5>Detecting an object using the Haar or LBP Classifier</h5>

<ol>
<li>Grayscale color conversion</li>
<li>Shringking the camera image</li>
<li>Histogram equalization</li>
</ol>


<h5>Detecting the face</h5>

<ul>
<li>CascadeClassifier::detectMultiScale()</li>
</ul>


<h2>Step2: Face preprocessing</h2>

<p>顔認識は、明るさ、顔の向き、顔の表情などに影響を受けやすい。<br/>
histogram equalizationだけで十分な場合もあるが、それでは不十分な場合も多い。</p>

<h5>Eye detection</h5>

<p>false positive : 検出すべきでないものも検出してしまうこと<br/>
false negative : 検出すべきものを検出しないこと</p>

<p>目を検出することにより、false positiveを避ける事が出来る</p>

<p>目を検出するもの</p>

<ul>
<li>haarcascade_mcs_lefteye.xml( or righteye)</li>
<li>haarcascade_lefteye_2splits.xml( or righteye)</li>
</ul>


<p>開いている目のみを検出するもの</p>

<ul>
<li>haarcascade_eye.xml</li>
<li>haarcascade_eye_tree_eyeglasses.xml</li>
</ul>


<h5>Eye search regions</h5>

<p>顔と目の検出が成功したら、以下の４つを実行</p>

<ul>
<li><p>Geometrical transformation and cropping</p>

<ul>
<li>Rotate the face so that the tow eyes are horizontal</li>
<li>Scale the face so that the distance between the tow eyes is always the same</li>
<li>Translate the face so that the eyes are always centered horizontally and at a desired height</li>
<li>Crop the outer parts of the face, since we want to crop away the image background, hair, forehead, ears, and chin</li>
</ul>
</li>
<li><p>Separate histogram equalization for left and right sides</p></li>
<li>Smoothing

<ul>
<li>Bilateral Filter

<ul>
<li>エッジ保持平滑化フィルタ、画像をスムーズにしつつもエッジ部分はぼかす事のない効果を持っている</li>
<li>ガウスぼかしをする際に、画素間の距離で重みを決めるのではなく、輝度の差も見て、変化が大きいところは重みを小さくすることによってエッジを残す</li>
</ul>
</li>
</ul>
</li>
<li>Elliptical mask</li>
</ul>


<h2>Step3: Collecting faces and learing from them</h2>

<h5>Collecting preprocessed faces for training</h5>

<p>集めた2つの画像の一致を調べるには次のようにする。</p>

<pre><code>double getSimilarity(const Mat A, const Mat B){
  double errorL2 = norm(A, B, CV_L2);
  double similarity = errorL2 / (double)(A.rows * A.cols);
  return similarity;
}
</code></pre>

<p>getSimilarityの値が0.3以上あれば画像が動いたと判断出来る</p>

<h5>Traing the face recognition system from collected faces</h5>

<p>顔認識を行うために、適切な機会学習アルゴリズムを用いる必要がある。</p>

<ul>
<li>Eigenfaces( Principal Component Analysis(PCA) )</li>
<li>Fisherfaces( Linear Discriminant Analysis(LDA) )</li>
<li>Other classic face recognition algorithms( <a href="http://www.face-rec.org/algorithms/">http://www.face-rec.org/algorithms/</a> )</li>
<li>Newer face recognition algorithms ( CVPR, ICCVなど )</li>
</ul>


<h5>Viewing the learned knowledge</h5>

<p>EigenfacesとFisherfacesの内部データ構造は同じ。<br/>
両者は一次元の固有ベクトルに基づいている。</p>

<h5>Average face</h5>

<h5>Eigenvalues, Eigenfaces, and Fisherfaces</h5>

<p>Eigenfacesの場合、3人×4つの顔：固有値は3×４＝12<br/>
Fisherfacesの場合、3人×4つの顔: 固有値は2つ ← なぜ3つではない？？</p>

<h2>Step4: Face recognition</h2>

<h5>Face identification: Recognizing people from their face</h5>

<h5>Face verificatoin: Validating that it is the claimed person</h5>

<p>to obtain good recognition accuracy, you will need to ensure
that the training set of each person covers the hull range of lighting conditions,
facial expressions, and angles that you expect to test with.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[今日からOctopress]]></title>
    <link href="http://TakashiNakagawa.github.io/blog/2013/05/17/hello/"/>
    <updated>2013-05-17T10:03:00+09:00</updated>
    <id>http://TakashiNakagawa.github.io/blog/2013/05/17/hello</id>
    <content type="html"><![CDATA[<h1>Octopressを使いはじめる</h1>

<p>以前もちょっとやっていたことがあったけども途中で止めてしまった。<br/>
また再開することに。<br/>
ここには技術的な事を書いて行きたいと思う。</p>

<p>何はともあれOctopressに投稿するための作業をメモしておく</p>

<pre><code>$ rake new_post["test"] # 新規記事を作成  
$ rake preview # preview, localhost:4000にアクセス  
$ rake generate # convert to html  
$ rake deploy # publish  
</code></pre>

<p>次回はOctopressのレイアウトを変更の仕方について調べたい</p>
]]></content>
  </entry>
  
</feed>
